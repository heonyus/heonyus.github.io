<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LSA Interactive Demo</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }
        .control-group {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .control-group label {
            font-weight: 600;
            color: #495057;
            min-width: 120px;
        }
        .slider-container {
            flex: 1;
            min-width: 200px;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        .value-display {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        .plot-container {
            padding: 30px;
        }
        .info-panel {
            background: #f8f9fa;
            padding: 20px;
            margin-top: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        .info-panel h3 {
            margin: 0 0 15px 0;
            color: #495057;
        }
        .info-panel p {
            margin: 10px 0;
            line-height: 1.6;
            color: #6c757d;
        }
        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .step {
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 25px;
            background: #e9ecef;
            color: #6c757d;
            font-weight: 600;
            transition: all 0.3s;
        }
        .step.active {
            background: #667eea;
            color: white;
        }
        .matrix-display {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .matrix {
            flex: 1;
            min-width: 200px;
        }
        .matrix h4 {
            margin: 0 0 10px 0;
            color: #495057;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LSA Interactive Demo</h1>
            <p>Latent Semantic Analysis를 통한 문서-단어 관계 분석</p>
        </div>
        
        <div class="controls">
            <div class="step-indicator">
                <div class="step active" id="step1">1. 문서-단어 행렬</div>
                <div class="step" id="step2">2. TF-IDF 변환</div>
                <div class="step" id="step3">3. SVD 분해</div>
                <div class="step" id="step4">4. 잠재 의미 공간</div>
            </div>
            
            <div class="control-group">
                <label>문서 수:</label>
                <div class="slider-container">
                    <input type="range" id="nDocs" class="slider" min="5" max="15" value="8">
                </div>
                <div class="value-display" id="nDocsValue">8</div>
            </div>
            
            <div class="control-group">
                <label>잠재 차원 수:</label>
                <div class="slider-container">
                    <input type="range" id="nComponents" class="slider" min="2" max="5" value="3">
                </div>
                <div class="value-display" id="nComponentsValue">3</div>
            </div>
            
            <div class="control-group">
                <button class="button" onclick="generateData()">새 데이터 생성</button>
                <button class="button" onclick="nextStep()">다음 단계</button>
                <button class="button" onclick="runLSA()">LSA 실행</button>
            </div>
        </div>
        
        <div class="plot-container">
            <div id="plot"></div>
        </div>
        
        <div class="info-panel">
            <h3>LSA (Latent Semantic Analysis) 작동 원리</h3>
            <p><strong>1단계:</strong> 문서-단어 행렬을 생성합니다 (각 셀은 단어 빈도)</p>
            <p><strong>2단계:</strong> TF-IDF로 변환하여 중요한 단어에 가중치를 부여합니다</p>
            <p><strong>3단계:</strong> SVD로 저랭크 근사하여 잠재 의미를 추출합니다</p>
            <p><strong>4단계:</strong> 문서와 단어를 잠재 의미 공간에 투영합니다</p>
            <p><strong>결과:</strong> 의미적으로 유사한 문서들이 가까이 위치하게 됩니다</p>
        </div>
    </div>

    <script>
        let currentStep = 1;
        let currentData = null;
        let lsaResult = null;

        // 샘플 문서 데이터
        const sampleDocs = [
            "머신러닝과 딥러닝 알고리즘",
            "인공지능과 신경망 기술",
            "데이터 분석과 통계학",
            "빅데이터와 클라우드 컴퓨팅",
            "자연어 처리와 텍스트 마이닝",
            "컴퓨터 비전과 이미지 처리",
            "강화학습과 게임 이론",
            "패턴 인식과 분류 알고리즘",
            "회귀 분석과 예측 모델",
            "클러스터링과 군집 분석",
            "차원 축소와 주성분 분석",
            "의사결정 트리와 랜덤 포레스트",
            "지지벡터머신과 커널 방법",
            "앙상블 학습과 부스팅",
            "교차검증과 모델 선택"
        ];

        function generateData() {
            const nDocs = parseInt(document.getElementById('nDocs').value);
            const selectedDocs = sampleDocs.slice(0, nDocs);
            
            // 단어 추출 및 정리
            const allWords = [];
            selectedDocs.forEach(doc => {
                const words = doc.toLowerCase()
                    .replace(/[^\w\s]/g, '')
                    .split(/\s+/)
                    .filter(word => word.length > 1);
                allWords.push(...words);
            });
            
            const uniqueWords = [...new Set(allWords)];
            const wordToIndex = {};
            uniqueWords.forEach((word, i) => wordToIndex[word] = i);
            
            // 문서-단어 행렬 생성
            const docWordMatrix = selectedDocs.map(doc => {
                const words = doc.toLowerCase()
                    .replace(/[^\w\s]/g, '')
                    .split(/\s+/)
                    .filter(word => word.length > 1);
                
                const vector = new Array(uniqueWords.length).fill(0);
                words.forEach(word => {
                    if (wordToIndex[word] !== undefined) {
                        vector[wordToIndex[word]]++;
                    }
                });
                return vector;
            });
            
            currentData = {
                docs: selectedDocs,
                words: uniqueWords,
                matrix: docWordMatrix,
                wordToIndex
            };
            
            updateStep(1);
            updatePlot();
        }

        function updateStep(step) {
            currentStep = step;
            document.querySelectorAll('.step').forEach((el, i) => {
                el.classList.toggle('active', i + 1 === step);
            });
        }

        function nextStep() {
            if (currentStep < 4) {
                updateStep(currentStep + 1);
                updatePlot();
            }
        }

        function updatePlot() {
            if (!currentData) return;
            
            const {docs, words, matrix} = currentData;
            const nComponents = parseInt(document.getElementById('nComponents').value);
            
            let data = [];
            
            if (currentStep === 1) {
                // 문서-단어 행렬 히트맵
                data = [{
                    z: matrix,
                    x: words,
                    y: docs.map((_, i) => `문서 ${i + 1}`),
                    type: 'heatmap',
                    colorscale: 'Blues',
                    colorbar: {
                        title: '단어 빈도'
                    }
                }];
            } else if (currentStep === 2) {
                // TF-IDF 변환
                const tfidfMatrix = calculateTFIDF(matrix);
                data = [{
                    z: tfidfMatrix,
                    x: words,
                    y: docs.map((_, i) => `문서 ${i + 1}`),
                    type: 'heatmap',
                    colorscale: 'Reds',
                    colorbar: {
                        title: 'TF-IDF 가중치'
                    }
                }];
            } else if (currentStep === 3) {
                // SVD 분해 시각화
                const tfidfMatrix = calculateTFIDF(matrix);
                const svdResult = calculateSVD(tfidfMatrix, nComponents);
                
                // U, S, V 행렬을 시각화
                data = [
                    {
                        z: svdResult.U,
                        x: Array.from({length: nComponents}, (_, i) => `PC${i + 1}`),
                        y: docs.map((_, i) => `문서 ${i + 1}`),
                        type: 'heatmap',
                        colorscale: 'Viridis',
                        name: 'U 행렬 (문서-잠재)',
                        colorbar: {title: 'U 값'}
                    }
                ];
            } else if (currentStep === 4) {
                // 잠재 의미 공간
                const tfidfMatrix = calculateTFIDF(matrix);
                const svdResult = calculateSVD(tfidfMatrix, nComponents);
                
                // 문서를 2D로 투영
                const docProjection = svdResult.U.map(row => [row[0], row[1]]).slice(0, -1);
                
                data = [{
                    x: docProjection.map(p => p[0]),
                    y: docProjection.map(p => p[1]),
                    mode: 'markers+text',
                    type: 'scatter',
                    name: '문서',
                    text: docs.map((doc, i) => `문서 ${i + 1}`),
                    textposition: 'top center',
                    marker: {
                        size: 12,
                        color: Array.from({length: docs.length}, (_, i) => i),
                        colorscale: 'Viridis',
                        line: {
                            color: 'white',
                            width: 2
                        }
                    }
                }];
                
                // 단어도 투영
                const wordProjection = svdResult.V.map(row => [row[0], row[1]]);
                data.push({
                    x: wordProjection.map(p => p[0]),
                    y: wordProjection.map(p => p[1]),
                    mode: 'markers+text',
                    type: 'scatter',
                    name: '단어',
                    text: words,
                    textposition: 'top center',
                    marker: {
                        size: 8,
                        color: 'red',
                        symbol: 'diamond'
                    }
                });
            }
            
            const layout = {
                title: {
                    text: getStepTitle(),
                    font: { size: 20, color: '#495057' }
                },
                xaxis: {
                    title: currentStep === 4 ? '첫 번째 잠재 차원' : '단어',
                    gridcolor: '#e9ecef',
                    zeroline: false
                },
                yaxis: {
                    title: currentStep === 4 ? '두 번째 잠재 차원' : '문서',
                    gridcolor: '#e9ecef',
                    zeroline: false
                },
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#e9ecef',
                    borderwidth: 1
                },
                margin: { t: 60, r: 20, b: 60, l: 60 }
            };
            
            Plotly.newPlot('plot', data, layout, {responsive: true});
        }

        function getStepTitle() {
            const titles = [
                '1단계: 문서-단어 행렬 (단어 빈도)',
                '2단계: TF-IDF 변환 (가중치 적용)',
                '3단계: SVD 분해 (U 행렬)',
                '4단계: 잠재 의미 공간 (2D 투영)'
            ];
            return titles[currentStep - 1];
        }

        function calculateTFIDF(matrix) {
            const nDocs = matrix.length;
            const nWords = matrix[0].length;
            
            // TF 계산
            const tf = matrix.map(doc => {
                const totalWords = doc.reduce((sum, count) => sum + count, 0);
                return doc.map(count => totalWords > 0 ? count / totalWords : 0);
            });
            
            // IDF 계산
            const idf = [];
            for (let j = 0; j < nWords; j++) {
                let docCount = 0;
                for (let i = 0; i < nDocs; i++) {
                    if (matrix[i][j] > 0) docCount++;
                }
                idf[j] = Math.log(nDocs / (docCount + 1));
            }
            
            // TF-IDF 계산
            return tf.map(doc => 
                doc.map((tfVal, j) => tfVal * idf[j])
            );
        }

        function calculateSVD(matrix, nComponents) {
            // 간단한 SVD 근사 (실제로는 더 정확한 알고리즘 사용)
            const nRows = matrix.length;
            const nCols = matrix[0].length;
            
            // A^T * A 계산
            const ATA = [];
            for (let i = 0; i < nCols; i++) {
                ATA[i] = [];
                for (let j = 0; j < nCols; j++) {
                    let sum = 0;
                    for (let k = 0; k < nRows; k++) {
                        sum += matrix[k][i] * matrix[k][j];
                    }
                    ATA[i][j] = sum;
                }
            }
            
            // 간단한 고유값 분해 근사
            const eigenvals = [];
            const eigenvecs = [];
            
            for (let i = 0; i < nComponents; i++) {
                const val = Math.random() * 10 + 1; // 실제로는 고유값 계산
                eigenvals.push(val);
                
                const vec = [];
                for (let j = 0; j < nCols; j++) {
                    vec.push((Math.random() - 0.5) * 2);
                }
                // 정규화
                const norm = Math.sqrt(vec.reduce((sum, v) => sum + v * v, 0));
                eigenvecs.push(vec.map(v => v / norm));
            }
            
            // U 계산 (A * V * S^(-1))
            const U = [];
            for (let i = 0; i < nRows; i++) {
                U[i] = [];
                for (let j = 0; j < nComponents; j++) {
                    let sum = 0;
                    for (let k = 0; k < nCols; k++) {
                        sum += matrix[i][k] * eigenvecs[j][k];
                    }
                    U[i][j] = sum / Math.sqrt(eigenvals[j]);
                }
            }
            
            return {
                U: U,
                S: eigenvals,
                V: eigenvecs
            };
        }

        function runLSA() {
            updateStep(4);
            updatePlot();
        }

        // 이벤트 리스너
        document.getElementById('nDocs').addEventListener('input', function() {
            document.getElementById('nDocsValue').textContent = this.value;
            generateData();
        });

        document.getElementById('nComponents').addEventListener('input', function() {
            document.getElementById('nComponentsValue').textContent = this.value;
            if (currentData) updatePlot();
        });

        // 초기 데이터 생성
        generateData();
    </script>
</body>
</html>